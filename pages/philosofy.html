<section class="text-gray-600 body-font">
    <div class="container mx-auto flex px-5 py-1 items-center justify-center flex-col">
        <div class="lg:w-2/3 w-full">
            <h1 class="pb-3 text-xl font-semibold text-gray-600">
                Tell don't ask
            </h1>
            <p class="text-gray-600 text-lg mb-4">
                Идея проекта зародилась из принципа <a href="https://toolshed.com/articles/1998-07-01-TellDontAsk.html" target="_blank">Tell don't ask</a>. Оригинальная версия принципа говорит о том, что мы не должны
                принимать решение какой метод объекта вызывать на основе данных от этого объекта, а должны просто сказать объекту что он должен сделать.
            </p>
            <p class="text-gray-600 text-lg mb-4">
                Этот принцип натолкнул на размышления о том, как на самом деле объекты в программе общаются друг с другом.
                Когда объект А вызывает метод объекта B и ожидает результат, который будет возвращен методом объекта
                B через return, такая организация кода заставляет объект B отвечать даже в те моменты,
                когда у объекта B нет какого-то хорошего, значащего результата.
            </p>
            <p class="text-gray-600 text-lg mb-4">
                Такая ситуация при использовании return заставляет объекты подобные B возвращать не полные результаты
                или вообще не возвращать результаты. Например, если объект B работает асинхронно, обащаясь к серверу, то
                объект B не может вернуть значение в условиях JS. Объект B может вернуть только Promise - обещание того
                что значение будет когда-то позже, но проблема в том, что сам объект B больше не отвечает за
                этот результат, результат может вернуться а может и не вернуться, даже если мы обработаем ошибку
                с помощью catch мы все равно обязаны что-то отвечать ожидающему объекту, что - то не значащее, что нужно
                будет перепроверять, а следовательно доверие к объекту B пропадет, каждый его ответ нужно проверять.
            </p>
            <p class="text-gray-600 text-lg mb-4">
                Также возможна ситуция, что у объекта B просто нет ответа и нам приходится возвращать null,
                а null переносит ответственность на объект который общается с объектом B. И получается
                что с объектом B уже общаться не приятно, потому что он не может гарантировать результат,
                его все время нужно перепроверять, никто ему не доверяет.
            </p>
            <h2 class="pb-3 text-xl font-semibold text-gray-600">
                Responsible
            </h2>
            <p class="text-gray-600 text-lg mb-4">
                О том что библиотека способствует тому что объекты
                будут отвечать за свой результат
            </p>
            <h2 class="pb-3 text-xl font-semibold text-gray-600">
                Result
            </h2>
            <p class="text-gray-600 text-lg mb-4">
                О том что класс - это результат, который нам нужен
                и что библиотека создавалась с этим принципом
            </p>
            <h2 class="pb-3 text-xl font-semibold text-gray-600">
                Посетитель + Наблюдатель
            </h2>
            <p class="text-gray-600 text-lg mb-4">
                О паттернах посетитель + наблюдатель в библиотеке
            </p>
        </div>
    </div>
</section>
